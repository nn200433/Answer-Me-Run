## 插件整理

|插件名|功能说明|
| --------------------------------------| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|🔥 Show Comment|在结构树显示 文档注释；在行末尾显示 文档注释；支持 "xx 类全名或简名.json" 文档注释与跳转到字段；支持 从配置文件获取外部注释用于文件夹、资源、COBOL 等<br />|
|🔥Draw Graph|生成 方法调用图 和 Maven 依赖图|
|🔥 .ignore|Git 提交忽略一些文件|
|AceJump|AceJump 允许您快速将插入符号导航到编辑器中可见的任何位置。只需按“ctrl+;”，输入一个字符，然后输入匹配的字符即可进行任意位置跳转。|
|Alibaba Cloud Toolkit|阿里云工具包是 Eclipse 或 IntelliJ IDEA 等 IDE 的插件。帮助开发人员更高效地开发、编码、测试、诊断和部署适合云操作的应用程序。|
|arthas idea|基于 IntelliJ IDEA 开发的 Alibaba Arthas 命令生成插件，支持 [Alibaba Arthas](https://arthas.aliyun.com/doc/) 官方常用的命令。|
|Awesome Console|有了这个插件，控制台和终端中的所有文件和链接都会被高亮显示并可以点击。源代码文件将在 IDE 中打开，其他链接将用该类型的默认查看器/浏览器打开。|
|any-rule|常用正则大全，快速搜索、易于使用。可不装，官方提供在线版 [https://any-rule.vercel.app/](https://any-rule.vercel.app/)|
|🔥 AnyDoor|目标：执行 Spring 项目任意对象的任意方法。<br />1. 对于是 Spring 注册的 Bean，会通过上下文拿到对象（若有代理既是代理对象），执行当前方法；<br />2. 对于非 Spring 注册的 Bean，会通过反射创建对象，执行当前方法<br />|
|Better Highlights|为注释着色、在注释中引用源代码、显示方法的认知复杂度、高亮显示区域（整行高亮）、在注释中引用文件、在注释中引用其他注释、高亮显示关键字（语法高亮）、通过 RegExp 高亮显示任何内容。|
|🔥 CamelCase|在 kebab-case、SNAKE_CASE、PascalCase、camelCase、snake_case 或 space case 之间轻松切换。（变量命名转换）|
|CodeGlance|将类似于 Sublime 中的代码小地图嵌入到编辑器窗格中。|
|🔥 CodeGlance Pro|在编辑器窗格中显示一个类似于 Sublime 中的放大概览或最小地图。小地图允许快速滚动，让你直接跳到代码的各个部分。对 CodeGlance 进行重做，支持更多的功能|
|Code Review Helper|Intellij IDEA的一个 Code Review 代码检视、代码评审的插件。可以在本地的IDEA工具中进行添加检视意见、评审意见等，支持Excel导入导出，可视化界面，方便项目中代码走读。[开源地址](https://gitee.com/veezean/IntellijIDEA-CodeReview-Plugin)|
|🔥 CommitMessage|提交信息模板生成插件，用于规范代码提交信息|
|🔥 JsonToAnyLanguage（$15/年）|日常开发中，我们经常要使用插件来实现 JSON 转业务实体，但是目前插件市场没有一款插件可以同时支持生成多种语言，导致需要下载很多个插件，很多强迫症患者是无法接受的。<br />基于这个背景，这个插件，统一把这些功能集成到一个插件中去。<br />该功能使用 [quicktype](https://quicktype.io/) 实现<br />|
|🔥 Easy Javadoc|这个插件可以帮助你快速完成中文 javadoc 文档。支持三种类型的 javadoc：字段、方法和类。|
|EasyCode|基于 IntelliJ IDEA 开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）。<br />只要是与数据库相关的代码都可以通过自定义模板来生成。支持数据库类型与 java 类型映射关系配置。<br />支持同时生成生成多张表的代码。每张表有独立的配置信息。完全的个性化定义，规则由你设置。<br />|
|🔥 EasyCode-MybatisCodeHelper|基于IntelliJ IDEA开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）。<br />支持Kotlin代码生成。<br />只要是与数据库相关的代码都可以通过自定义模板来生成。支持数据库类型与java类型映射关系配置。<br/>支持同时生成生成多张表的代码。每张表有独立的配置信息。完全的个性化定义，规则由你设置。<br/>插件fork于easy code插件，该版本用于兼容MybatisCodeHelper插件，方便MybatisCodeHelper插件做代码生成补全检测等<br/>支持从项目的easyCode目录里面的模版文件来生成代码 表上右键GenerateFromEasyCodeFolderFile即可<br/>写模版有代码提示,更好的报错提示,支持自定义多个group来生成代码。<br/>（<b>模板可以项目组共享，个人感觉比EasyCode好用</b>）|
|EasyYapi|帮助你导出 api 到 yapi 、postman 、markdown（基于 javadoc & KDoc & ScalaDoc 解析 API 文档）<br />不使用 [YApi](https://hellosean1025.github.io/yapi/) 可不装，若使用 [YApi](https://hellosean1025.github.io/yapi/) 管理接口文档，推荐安装。|
|element|支持 element 框架，在使用这个插件之前，你必须安装插件 vuejs|
|GitToolBox|Git 工具箱。扩展 Git 功能：状态显示、自动获取、内联错误注释、提交对话框完成、隐藏通知...|
|🔥 Grep Console|Grep、tail、filter、highlight... 控制台所需的一切。也可以高亮编辑器...|
|🔥 Gyro|Gyro-让你的本地集成测试一直运行，就像 @SpringBootTest 启动的那样。第一次运行 Gyro Debug 时，需要启动 Spring 容器。当你再次运行 Gyro Debug 时，Gyro 将重用之前启动的 Spring 容器。<br />安装 Jrebel 热部署插件会自动使用 Jrebel 热部署能力（如果没有生效，可以通过 Preferences->Tools->Gyro Settings 配置 Jrebel 代理路径）；同样，您可以使用它来预热您的其他测试任务。<br />|
|Keep Unit Test Running|以连续模式运行 JUnit 或 TestNG 测试 -> 如果修改测试，无需重新启动整个应用程序 -> 提高工作效率。与 Spring 和 Cucumber 配合使用效果特别好。（SpringBoot 支持很差）|
|JFormDesigner|先进的 Swing GUI 设计器，对 MigLayout、JGoodies FormLayout、GroupLayout (Free Design)、TableLayout 和 GridBagLayout 的出色支持，使其能够轻松创建专业外观的表单。|
|🔥 JRebel and XRebel|JRebel 是一种生产力工具，允许开发人员立即重新加载代码更改。它跳过了 Java 开发中常见的重建、重新启动和重新部署周期。<br />XRebel 是一个用于 Java 开发的性能工具，它为开发人员提供实时性能洞察，帮助他们在开发阶段更快、更早地理解和解决潜在问题。<br />|
|🔥 JRebel mybatisPlus extension|用于 IntelliJ 的 JRebel MybatisPlus 热重载扩展|
|Jump to Line|Jump to Line 插件允许您在调试时访问任何代码行。将黄色箭头拖放到排水沟中的所需位置，它将在那里放置一个执行点。<br />与步进相比，该插件使您可以从该点开始运行程序，而无需执行前面的代码。<br />|
|🔥 Maven Helper|使用 Maven 的必备插件。（分析和排除冲突依赖项的简单方法）|
|🔥 maven-search|快速查找 maven 依赖，定制模糊查找算法。支持查找全网类。不依赖于国外网络，每周自动去 Maven 仓库同步索引到国内。<br />在线版：[https://mvn.coderead.cn/](https://mvn.coderead.cn/)<br />|
|MetricsReloaded|分析代码复杂度的插件|
|Momo Code Sec Inspector（Java）|Java 静态代码安全审计插件。具有一键修复功能的静态代码检查器。|
|🔥 MyBatisCodeHelperPro（¥99/3 年）|Intellij 下 Mybatis 支持插件，功能强大（[详细介绍](https://gejun123456.github.io/MyBatisCodeHelper-Pro/#/)）。不想付费那就用 [MyBatisX](https://plugins.jetbrains.com/plugin/10119-mybatisx)|
|🔥 Rainbow Brackets（¥280/永久）|彩虹括号，高亮括号对。注意，会检测 `ja-netfilter` 。付费都无法使用用！！！可以用免费版。|
|🔥 HighlightBracketPair|该插件可以在 IntelliJ 的编辑器中对括号对进行颜色突出显示。|
|🔥 Restful Fast Request（$19/年）|Restful Fast Request 是一个强大的 restful api 工具包插件（http 客户端），帮助您通过 exist 方法快速生成 url 和 params。<br />插件= API 调试工具 + API 管理器工具。<br />|
|RestfulToolkitX|RestfulToolkitX 是运行在Intellij IDEA 之上的一个非常棒的 RESTful 开发工具包。（主要用来搜索接口）|
|🔥 Apipost-Helper|Apipost 一个类似于 Postman 的 IntelliJ IDEA 插件，可以帮助开发人员高效地调试 Api 并一键生成文档；Apipost \= Restfultool + Yapidoc + Swaggertool；|
|RequestTool|[RequestTool](https://licheng1013.github.io/plugins/request-tool.html) 一个 Http 请求工具，您可以根据请求结果构建自己的文档，支持文档导出。（与 Restful Fast Request 相比，个人觉得能达到近 2/3 吧）<br />|
|Save Actions|支持可配置的、类似 Eclipse 的保存操作，包括“优化导入”、“重新格式化代码”、“重新排列代码”、“编译文件”以及一些针对 Java 的快速修复，<br />如“添加/删除 'this' 限定符”等。当文件在磁盘上同步（或保存）时执行配置的操作。<br />请注意，自 `IntelliJ 2021.2`​ 以来，有一个内置的 `Tools > Actions on Save`​ 设置菜单，允许您执行许多标准操作，例如重新格式化或优化导入。若您还想使用本插件可参考下方详细使用介绍。<br />|
|🔥Smart Input|自动切换输入法。对于母语为中文的开发者，写代码过程中经常需要在中/英输入法之间进行切换，而且由于不清楚当前处于哪种输入状态，有时输入到一半发现输入法错了，删除后重新输入，严重影响了编码效率。<br />其实，在哪种情况需要使用哪种输入法是可以明确的，既然这样就可以让 IDE 帮助我们自动切换输入法。|
|Spring Boot Assistant|该插件为 Spring Boot 配置文件（application.yml 等）添加了自动完成支持。|
|Statistic|显示项目统计信息。此插件显示按扩展名排序的文件以及大小、行数 LOC 等。用户可以使用“选择时刷新”按钮选择（项目/模块/包/文件）范围。|
|String Manipulation|对字符串的大小写切换、排序、过滤、递增、与列对齐、grepping、转义、编码。|
|🔥 Translation|基于 IntelliJ 的 IDE 的翻译插件。|
|Vue.js|支持 Vue.js 项目。|
|🔥 MapStruct support|MapStruct 是一款基于 Java 注解的对象属性映射工具。当我们使用它的 IDEA 插件时，他能自动提示映射对象所包含的属性，并且在点击属性时能跳转到对应属性。<br />|
|Private Notes|你还在为项目中不敢添加 "敏感注释"！源码是只读文件不能添加注释而烦恼吗？<br />用这款插件就好了，注释仅自己可见。数据都缓存当前用户目录下的 .privateNotes 文件夹中，如需同步，可以借助强大的 Git。|
|GenerateSerialVersionUID|在生成菜单 (alt + ins) 中添加新操作“SerialVersionUID”。该操作在当前类中添加一个 serialVersionUID 字段或更新它（如果它已经存在），并为其分配标准“serialver”JDK 工具将返回的相同值。<br />IDEA 自带生成方式见 [【开发工具】IDEA 生成序列号 serialVersionUID 快捷键](https://blog.csdn.net/u011397981/article/details/119743032)|
|JDK VisualGC（$9/年）|用于本地或远程运行 Hotspot JVM 的实时可视化垃圾收集监控工具，支持 G1 和 ZGC|

### ~~Save Actions（格式化代码插件）~~

可以帮忙我们优化包导入，自动给没有修改的变量添加 final 修饰符，调用方法的时候自动添加 this 关键字等，使我们的代码更规范统一。

注意！！！该插件在 `2023.1`​ 版本下使用有 Bug ！！！

#### 我的设置

​![image](assets/image-20221129144256-l05ssw6.png)​

​![image](assets/image-20221129144330-80k6hrw.png)​

#### 设置详解

##### General 基本设置

* Activate save actions on save(before saving each file,performs the configured actions below)

  保存时自动格式化（在文件保存时启用/禁用该插件。在保存每个文件之前，它将执行以下配置的动作）
* Activate save actions on shortcut

  使用快捷键保存时自动格式化

  使用场景：收到一份格式很乱的文件，可以使用这个快捷键自动格式化
* Activate save actions on batch(Code>Save Actions>Execute on multiple files)

  保存时批量格式化

  这个没用过，因为有的时候你的格式化设置和同事的不一样，一起格式化了会导致合并时候有冲突
* No action if compile errors

  如果有编译错误，则启用/禁用无动作。单独应用于每个文件

##### Formatting Actions 格式化触发设置

* Optimize imports

  优化导入（没有用到的类自动删去 import，这个一般要勾选）
* Reformat file

  重新格式化文件（只要保存文件就会自动格式化）
* Reformat only changed code (only if VCS configured)

  仅重格式化已(仅在配置 VCS 的情况下)

  只有在配置了 VCS 的情况下，才可以对更改的代码进行格式化。
* Rerrange fields and methods(configured in “File>Setting>Editor>Code Style>(…)>Arragement”)

  重新调整字段和方法的范围

##### Build Actions build 设置

* Compile file

  编译文件

  对修改后的文件进行编译。编译器可能也会编译其他文件。
* Reload file

  重新加载文件

  在运行中的调试器中重新加载文件，意味着这些文件将首先被编译。编译器可能也会编译其他文件。
* Execute action

  执行动作

  使用快速列表执行动作

##### Java Inspection and Quick Fix 具体格式化设置

* Add final modifier to field

  给字段添加 `final`​ 修饰符

  ```java
  private int field = 0

  // 变为

  private final int field = 0
  ```
* Add final modifier to local variable or parameter

  向局部变量或参数添加 `final`​ 修饰符

  使用效果如下，所有的局部参数都添加了 `final`​ 修饰符

  ```java
  public void printStr(String str1, String str2, String str3) {
      int variable = 0
      System.out.println(str1 + str2 + str3);
  }

  // 变为

  public void printStr(final String str1, final String str2, final String str3) {
      final int variable = 0
      System.out.println(str1 + str2 + str3);
  }
  ```
* Add final modifier to local variable or parameter except if it is implicit

  向非隐式的局部变量或参数添加 final 修饰符

  局部变量 `int variable = 0`​ 变为 `final int variable = 0`​ ，但如果它是隐式的，就像在 try 中的资源 `try (Resource r = new Resource())`​

  不太理解这个非隐式是什么意思
* Add static modifier to methods

  如果内容不引用实例字段，给方法添加 `static`​ 修饰符

  ```java
  private void testStatic(String str) {
      System.out.println(str);
  }

  // 变为

  private static void testStatic(String str) {
      System.out.println(str);
  }
  ```
* Add this to field access

  字段的使用加上 `this`​
* Add this to method access

  方法使用加上 `this`​
* Add class qualifier to static member access

  静态成员访问添加类限定符

  对类字段的访问 `FIELD = 0`​ 变为 `Class.FIELD`​ 对名为 Class 的类的访问。与“Add class qualifier to static member access outside declaring class only”互斥。
* Add class qualifier to static member access outside declaring class only

  声明类外的静态成员访问添加类限定符

  对于一个名为 `class`​ 的类，对类字段 `FIELD = 0`​ 的访问变为 `Class.FIELD`​ ，但只有当静态成员在声明类之外时才会如此。与“Add class qualifier to static member access”互斥。
* Add missing @Override annotations

  如果方法覆盖了父类的一个方法，添加漏写的 `@Override`​ 注解

  ```java
  void method()

  // 变为

  @Override
  void method()
  ```
* Add blocks to if/while/for statements

  给 if/while/for 语句添加大括号

  ```java
  public String judgeIt(int a) throws Exception {
      if (a == 3) return "yes";
      throw new Exception();
  }

  // 变为

  public String judgeIt(int a) throws Exception {
      if (a == 3) {
          return "yes";
      }
      throw new Exception();
  }
  ```
* Add missing serialVersionUID field for Serializable classes

  为 `Serializable`​ 类添加缺少的 `serialVersionUID`​ 字段

  ```java
  public class BasicEntity implements Serializable {

      // 这是生成的
      private static final long serialVersionUID = -1134102816751244744L;

  }
  ```
* Remove blocks from if/while/for statements

  给 if/while/for 语句移除大括号

  ```java
  public String judgeIt(int a) throws Exception {
      if (a == 3) {
          return "yes";
      }
      throw new Exception();
  }

  // 变为

  public String judgeIt(int a) throws Exception {
      if (a == 3) return "yes";
      throw new Exception();
  }
  ```
* Remove unnecessary this to field and method

  给字段或者方法去掉不必要的 `this`​

  ```java
  this.field = 0

  // 变为

  field = 0
  ```
* Remove final from private method

  私有方法去掉 `final`​ 关键字

  ```java
  private final String getStr(final String str) {
      return str;
  }

  // 变为

  private String getStr(final String str) {
      return str;
  }
  ```
* Remove unnecessary final to local variable or parameter

  局部变量去掉 `final`​

  ```java
  int final variable = 0

  // 变为

  int variable=0
  ```
* Remove explicit generic type for diamond

  删除显式泛型类型的尖括号

  ```java
  List<String> list = new ArrayList<String>()

  // 变为

  List<String> list = new ArrayList<>()
  ```
* Remove unused suppress warning annotation

  如果注解 `@SuppressWarning`​ 未被使用，它将被删除
* Remove unnecessary semicolon

  删除不必要的分号

  ```java
  int variable = 0;;

  // 变为

  int variable = 0;
  ```
* Change visibility of field or method to lower access

  更改字段或方法的可见性以降低访问权限。如果字段不在类外使用，将把 `public`​ 改为 `private`​ 。它也适用于方法。

  ```java
  public int field = 0

  // 变为

  private int field = 0
  ```

## VM 参考配置

```properties
# 堆栈设置
# 设置堆的初始大小和最大大小
-Xms4g
-Xmx4g

# 元空间设置
# 设置元空间的初始大小和最大大小
-XX:MetaspaceSize=512m
-XX:MaxMetaspaceSize=1024m

# 代码缓存设置
# 设置初始代码缓存大小和保留代码缓存大小
-XX:InitialCodeCacheSize=512m
-XX:ReservedCodeCacheSize=1024m

# 垃圾回收参数
# 使用并发标记清除（ConcMarkSweep）垃圾回收器
-XX:+UseConcMarkSweepGC
# 设置并行垃圾回收线程数
-XX:ParallelGCThreads=4

# JIT（即时编译）参数
# 设置编译器线程数
-XX:CICompilerCount=2
# 设置停止级别，只进行第一级别的编译
-XX:TieredStopAtLevel=1
# 设置最大内联级别
-XX:MaxInlineLevel=9
# 设置第四层（Tier 4）最小调用阈值
-XX:Tier4MinInvocationThreshold=50000
# 设置第四层（Tier 4）调用阈值
-XX:Tier4InvocationThreshold=100000
# 设置第四层（Tier 4）编译阈值
-XX:Tier4CompileThreshold=150000

# 其他设置
# 禁用规范化的文件路径缓存
-Dsun.io.useCanonPrefixCache=false
# 设置首选使用IPv4协议栈
-Djava.net.preferIPv4Stack=true
# 禁用HTTP隧道身份验证
-Djdk.http.auth.tunneling.disabledSchemes=""

# 错误日志和堆转储设置
# 在发生内存溢出错误时生成堆转储文件
-XX:+HeapDumpOnOutOfMemoryError
# 禁用快速抛出异常时的堆栈跟踪省略
-XX:-OmitStackTraceInFastThrow
# 允许自我附加
-Djdk.attach.allowAttachSelf

# 错误日志文件路径
-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log
# 堆转储文件路径
-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof

# 其他配置
# 打开指定包的包访问权限
--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED
--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED
# 虚拟机在启动时预先分配堆空间
-XX:+AlwaysPreTouch
# 启用压缩指针（Compressed Oops）技术。在64位的JVM中，启用压缩指针可以减少对象引用的内存占用，提高堆的使用效率。
-XX:+UseCompressedOops
# 设置文件编码为UTF-8
-Dfile.encoding=UTF-8
# 破解包位置
-javaagent:D:\ja-netfilter\ja-netfilter.jar=jetbrains
# JDK VisualGC 插件
--add-exports=jdk.internal.jvmstat/sun.jvmstat.monitor=ALL-UNNAMED
--add-exports=jdk.internal.jvmstat/sun.jvmstat.monitor.event=ALL-UNNAMED
--add-exports=jdk.internal.jvmstat/sun.jvmstat.perfdata.monitor=ALL-UNNAMED
```

## JetBrains Toolbox App

个人觉得这是**必装**的一个软件！！！它可以轻松地管理您的 IDE。

功能特点如下：

1. 快速轻松地更新管理您的 JetBrains 工具，包含 安装、自动更新、同时更新插件和 IDE 、回滚和降级

   通过下载补丁或一组补丁而不是整个包，节省维护 IDE 的时间和精力。在您编程的同时，在后台更新所有内容。
2. 查看最新变化

   借助 JetBrains Toolbox App，您可以在更新之前阅读有关 IDE 中的最新功能和错误修复的所有信息。
3. 同时维护多个版本

   轻松处理同一工具的多个版本。通过 JetBrains Toolbox App 安装和更新，第一时间享受 JetBrains IDE 抢先体验计划 (EAP) 和 Google 的 Android Studio 版本与 Canary 构建。
4. 即时打开项目

   所有项目都唾手可得，而且您的收藏夹固定在顶部。使用 Search 字段快速找到它们，只需点击一次即可在 IDE 中立即将其打开。
5. 连接到团队工具

   登录您的 JetBrains Space，从“项目”标签页中一键访问您最喜欢的项目。
6. 与 GitHub、GitLab 或 Bitbucket 集成

   安装 [Google Chrome](https://chrome.google.com/webstore/detail/jetbrains-toolbox/offnedcbhjldheanlbojaefbfbllddna) 或 [Firefox](https://addons.mozilla.org/en-US/firefox/addon/jetbrains-toolbox/) 的扩展，您就可以直接从浏览器中克隆并打开 GitHub、GitLab 或 Bitbucket 仓库。

主要功能截图如下：

​![image](assets/image-20230515080351-wscxa8u.png)​

## IDEA 的一些优化

官方配置详细介绍：[https://www.jetbrains.com/help/idea/getting-started.html](https://www.jetbrains.com/help/idea/getting-started.html)

### 自定义代码模板

举个例子：只要输入 apr，就能自动提示，并且生成 `@Autowired`​ 语句。

可以根据自己的代码习惯，自定义一些代码模板，帮助我们快速写代码。

​​![image](assets/image-20230510112546-xwm1g55.png)​​

使用效果如图：

​![image](assets/image-20230510112757-thckdz8.png)​

### 修改全局配置

#### 优化导包配置

​​![image](assets/image-20230510113929-ehlneuw.png)

打开设置，找到 File | Settings | Editor | Code Style | Java 界面的 imports 页签，导入数量设置为 `999`​，如下图，这样就会避免导包为 `*`​

​![image](assets/image-20230906154942-nhmu9xm.png)​

#### 解决注释只读模式

##### 方式一

去掉 `Render documentation comments`​ 勾选即可。

​![image](assets/image-20230906153642-gbpzfux.png)​

##### 方式二

似乎只需要进行下方两步操作即可。

​![image](assets/image-20230906155642-ldsgc9p.png)​

其他说明（似乎上方执行后即可.....）：

​![image](assets/image-20230906152024-21guwv7.png)​

#### 取消 tab 页单行显示

​​![image](assets/image-20230510114533-bh6f6x6.png)​​

去掉勾选后，效果如下：

​​![image](assets/image-20230510114541-dfipxzx.png)​​

#### 代码格式化风格

举个例子：变量对齐

​![image](assets/image-20230510123037-qilwd3a.png)

我的配置（点击 Scheme 右边的小齿轮可以导入）：

```xml
<code_scheme name="Default" version="173">
  <JavaCodeStyleSettings>
    <option name="GENERATE_FINAL_LOCALS" value="true" />
    <option name="REPLACE_INSTANCEOF_AND_CAST" value="true" />
    <option name="ALIGN_MULTILINE_TEXT_BLOCKS" value="true" />
    <option name="JD_DO_NOT_WRAP_ONE_LINE_COMMENTS" value="true" />
  </JavaCodeStyleSettings>
  <codeStyleSettings language="JAVA">
    <option name="LINE_COMMENT_AT_FIRST_COLUMN" value="false" />
    <option name="BLOCK_COMMENT_AT_FIRST_COLUMN" value="false" />
    <option name="LINE_COMMENT_ADD_SPACE" value="true" />
    <option name="BLOCK_COMMENT_ADD_SPACE" value="true" />
    <option name="LINE_COMMENT_ADD_SPACE_ON_REFORMAT" value="true" />
    <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
    <option name="ALIGN_MULTILINE_THROWS_LIST" value="true" />
    <option name="ALIGN_MULTILINE_EXTENDS_LIST" value="true" />
    <option name="ALIGN_MULTILINE_ARRAY_INITIALIZER_EXPRESSION" value="true" />
    <option name="ALIGN_GROUP_FIELD_DECLARATIONS" value="true" />
    <option name="ALIGN_CONSECUTIVE_VARIABLE_DECLARATIONS" value="true" />
    <option name="ALIGN_CONSECUTIVE_ASSIGNMENTS" value="true" />
    <option name="ALIGN_SUBSEQUENT_SIMPLE_METHODS" value="true" />
    <option name="PREFER_PARAMETERS_WRAP" value="true" />
    <option name="METHOD_PARAMETERS_WRAP" value="1" />
    <option name="RESOURCE_LIST_WRAP" value="1" />
    <option name="EXTENDS_LIST_WRAP" value="1" />
    <option name="THROWS_LIST_WRAP" value="1" />
    <option name="EXTENDS_KEYWORD_WRAP" value="1" />
    <option name="THROWS_KEYWORD_WRAP" value="1" />
    <option name="METHOD_CALL_CHAIN_WRAP" value="5" />
    <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />
    <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />
    <option name="ARRAY_INITIALIZER_WRAP" value="1" />
    <option name="ARRAY_INITIALIZER_LBRACE_ON_NEXT_LINE" value="true" />
    <option name="ARRAY_INITIALIZER_RBRACE_ON_NEXT_LINE" value="true" />
    <option name="WRAP_COMMENTS" value="true" />
    <option name="IF_BRACE_FORCE" value="3" />
    <option name="DOWHILE_BRACE_FORCE" value="3" />
    <option name="WHILE_BRACE_FORCE" value="3" />
    <option name="FOR_BRACE_FORCE" value="3" />
    <option name="ENUM_CONSTANTS_WRAP" value="2" />
  </codeStyleSettings>
</code_scheme>
```

#### Tab 转 空格

​![image](assets/image-20240314150229-f5ue803.png)​

#### 双斜杠注释紧跟代码头

​​![image](assets/image-20230510115652-mbvai8u.png)​​

去掉勾选后，效果如下：

​![image](assets/image-20230510115845-a8636cl.png)​

#### 取消匹配大小写

​​![image](assets/image-20230510120130-2g24zhd.png)​​

去掉勾选后，效果如下：

​![image](assets/image-20230510120250-2d6jgb3.png)​

输入小写 `s`​，也能提示出 `String`​

#### 创建文件时生成作者和时间信息

​![image](assets/image-20230510120641-gbjkf8p.png)​

#### 显示行号和方法分割线

​​![image](assets/image-20230510121122-scq7gos.png)​​

选中后效果如下：

​![image](assets/image-20230510121209-vwob1ar.png)​

#### 代码保存后自动触发操作

​![image](assets/image-20230510132936-sddr22j.png)

保存文件的一些配置

​![image](assets/image-20230512145325-qh4ol50.png)​

可参考 [Rearrange code 官方教程](https://www.jetbrains.com/help/idea/rearrange-code.html)

#### 忽略文件和文件夹

IntelliJ IDEA 还维护着一个文件和文件夹列表，这些文件和文件夹完全被排除在任何处理之外（包含搜索等）。该列表包括临时文件、与版本控制系统相关的服务文件等。笔者一般是加上下面几个忽略：

```
.flattened-pom.xml
.fastRequest
```

​![image](assets/image-20240122134302-wqe9p50.png)​

#### 新版 IDEA 没有 Local Changes

​![image](assets/image-20240129104656-5l96he8.png)​

#### 取消 AI 自动补全

![image](assets/image-20240627173715-vxk983n.png)​

## 一些问题

### 不想要 Services 窗口怎么操作？

当你的项目是 SpringBoot 项目时，又不小心开启了 Services 。跑项目时都是在那逗比的 Services 框框里，又很烦，这时候该怎么操作关闭呢？

1. 打开 Services 窗口，果断的选择 Spring Boot 分钟，然后干净利落的右键点击 Delete 按钮删除。这时，不出意外的话，Services 窗口已经消失了。

    ​![image](assets/image-20240313160035-un4pqem.png)​
2. 直接点击右上角的 Debug 运行项目，就又能开心的看到简单的 Run 窗口了。

    ​![image](assets/image-20240313160058-loecfpu.png)​

### Jrebel debug 无法启动

在新版本的 IDEA 中 Jrebel debug 模式无法正常工作时，可尝试进行一下以下设置。

​![image](assets/image-20240313143815-n2c2uys.png)​

### Easy Yapi

​![image](assets/image-20240313150203-0jdgaer.png)​

## 参考文章

1. [玩转 IDEA](https://juejin.cn/column/7079814112984694814)
